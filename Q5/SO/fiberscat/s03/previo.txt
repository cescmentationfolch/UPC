1. 

0804a02c B j
080484b4 T suma

Unicamente podemos saber la dirección de la variable j, ya que es global.
Intuimos que j estará en la sección de datos e i estará en la sección de datos dinámicos (heap).

2. Modificación realizada [archivo adjunto]

int *s=malloc(4);
suma (i, j, s);

3.

Para enlazar con librerías estáticas utilizamos el argumento -static: gcc -static -o mem1_previo mem1_previo.c
Si vovemos a consultar el espacio con nm aparece mucho más espacio definido seguramente por las librerias estáticas. 

4. 
Modificación realizada [archivo adjunto]
   int *vector;
  n = readint ();
  vector=sbrk(n*sizeof(int));
  fillvector (vector, n);

5.
Formato del archivo maps: address  perms offset  dev   inode   pathname

Información del /proc/[PID/maps de mem2_previo (i=10, i=40000):

00e7e000-00ea1000 rw-p 00000000 00:00 0                                  [heap]
7ffff9906000-7ffff9927000 rw-p 00000000 00:00 0                          [stack]

00c1c000-00c3f000 rw-p 00000000 00:00 0                                  [heap]
7fff66111000-7fff66132000 rw-p 00000000 00:00 0                          [stack]

Información del /proc/[PID/maps de mem2_previo_v2 (i=10, i=40000):

00fbb000-00fdf000 rw-p 00000000 00:00 0                                  [heap]
7fff0e6ff000-7fff0e720000 rw-p 00000000 00:00 0                          [stack]

00dfa000-00e45000 rw-p 00000000 00:00 0                                  [heap]
7fff51646000-7fff51667000 rw-p 00000000 00:00 0                          [stack]


Sí que hay una diferencia; en mem2_previo, el espacio reservado en memoria siempre es fijo (recordemos la declaración del vector); en mem2_previo_v2, en cambio, el espacio varía según el número de elementos del vector.



6.
Modificación realizada [archivo adjunto]


